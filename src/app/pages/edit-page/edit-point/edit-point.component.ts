import {
	Component,
	OnInit,
	OnDestroy,
	ChangeDetectionStrategy,
	ViewChild,
	ElementRef,
	ChangeDetectorRef,
	HostBinding,
	AfterViewInit,
} from '@angular/core';
import { FormControl, FormGroup, Validators } from '@angular/forms';
import { ActivatedRoute, Router } from '@angular/router';
import {
	Subscription,
	interval,
	debounce,
	timer,
	BehaviorSubject,
	of,
	distinctUntilChanged,
	pairwise,
	tap,
	startWith,
	mergeMap,
	filter,
	combineLatestWith,
	from,
	take,
} from 'rxjs';
import { Point, Iteration, UserExtraData, SwitcherItem, SelectArray, PointMode, GroupEmoji } from 'src/app/interfaces';
import { DataService, AuthService, ActionService, NotifyService } from 'src/app/services';
import { addMonths, addYears, format, getYear, intervalToDuration, setYear, startOfDay, subMinutes } from 'date-fns';
import { getInvertedObject, getPointDate, isDateValid, parseDate, setIterationsMode, sortDates } from 'src/app/helpers';
import { Constants, PointColors } from 'src/app/enums';
import { CalendarMode, DifferenceMode, EditPointEvent, PointColorTypes } from 'src/app/types';
import { DropComponent } from '../../../components/drop/drop.component';
import { fetchEmojis, fetchMessages } from 'emojibase';
import { DatePanelComponent } from '../../point-page/date-panel/date-panel.component';
import {
	millisecondsInDay,
	millisecondsInHour,
	millisecondsInMinute,
	minutesInDay,
	minutesInHour,
} from 'date-fns/constants';

enum EditPointType {
	Create = 'create',
	Edit = 'edit',
	CreateUrl = 'create-url',
}

enum EditPointSuccessMessage {
	pointAdded = '–°–æ–±—ã—Ç–∏–µ –¥–æ–±–∞–≤–ª–µ–Ω–æ',
	pointEdited = '–°–æ–±—ã—Ç–∏–µ –∏–∑–º–µ–Ω–µ–Ω–æ',
	iterationAdded = '–ò—Ç–µ—Ä–∞—Ü–∏—è –¥–æ–±–∞–≤–ª–µ–Ω–∞',
	iterationEdited = '–ò—Ç–µ—Ä–∞—Ü–∏—è –∏–∑–º–µ–Ω–µ–Ω–∞',
	iterationsGenerated = '–ò—Ç–µ—Ä–∞—Ü–∏–∏ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω—ã',
	iterationRemoved = '–ò—Ç–µ—Ä–∞—Ü–∏—è —É–¥–∞–ª–µ–Ω–∞',
	iterationsRemoved = '–ò—Ç–µ—Ä–∞—Ü–∏–∏ —É–¥–∞–ª–µ–Ω—ã',
}

@Component({
	selector: 'app-edit-point',
	templateUrl: './edit-point.component.html',
	changeDetection: ChangeDetectionStrategy.Default,
})
export class EditPointComponent implements OnInit, OnDestroy, AfterViewInit {
	@ViewChild('iterationForm') iterationForm!: ElementRef;
	@ViewChild('colorDrop') private colorDrop!: DropComponent;
	@ViewChild('modesDrop') private modesDrop!: DropComponent;
	@ViewChild('datePanel') datePanel!: DatePanelComponent;
	@HostBinding('class') class = 'main__inner';
	type = EditPointType.Edit;
	form!: FormGroup;
	point: Point | undefined;
	pointDate = new Date();
	difference = 0;
	loading = false;
	validatorDifferenceMaxLength = 10;
	currentIterationIndex!: number;
	firstIterationIndex = 0;
	removedIterationIndex = 0;
	isIterationAdded = false;
	isCalendarCreated = false;
	isCalendarPanelOpen = false;
	iterationControls = {};
	iterationsChecked: number[] = [];
	selectedIterationDate = new Date();
	selectedIterationsNumber = 0;
	calendarMode!: CalendarMode;
	userData!: UserExtraData;
	isIterationSwitched = false;
	showIterationsInfo = false;
	pointModes: PointMode[] = [];
	isModesDropOpened = false;
	differenceMode: DifferenceMode = (localStorage.getItem('differenceMode') as DifferenceMode) || 'minutes';
	dateUrlMode: 'date' | 'timer' = 'date';

	directionList: SwitcherItem[] = [
		{
			text: '–û–±—Ä–∞—Ç–Ω—ã–π –æ—Ç—Å—á—ë—Ç',
			value: 'backward',
			icon: 'rotate-left',
		},
		{
			text: '–ü—Ä—è–º–æ–π –æ—Ç—Å—á—ë—Ç',
			value: 'forward',
			icon: 'rotate-right',
		},
	];

	dateModeList: SwitcherItem[] = [
		{
			text: '–î–∞—Ç–∞',
			value: 'date',
			icon: 'calendar-clock',
		},
		{
			text: '–¢–∞–π–º–µ—Ä',
			value: 'timer',
			icon: 'hourglass',
		},
	];

	differenceModeArray: SelectArray[] = [
		{
			key: '–ú–∏–Ω—É—Ç—ã',
			value: 'minutes',
		},
		{
			key: '–ß–∞—Å—ã',
			value: 'hours',
		},
		{
			key: '–î–Ω–∏',
			value: 'days',
		},
		{
			key: '–ù–µ–¥–µ–ª–∏',
			value: 'weeks',
		},
		{
			key: '–ú–µ—Å—è—Ü—ã',
			value: 'months',
		},
		{
			key: '–ì–æ–¥—ã',
			value: 'years',
		},
	];

	emojis: GroupEmoji[] = [];

	private _debounceTime = 500;
	private subscriptions = new Subscription();
	notifies: {
		[key: string]: {
			date: Date | undefined;
			remove: () => void;
		};
	} = {
		greenwich: {
			date: undefined,
			remove: () => {
				this.closeNotify('greenwich');
			},
		},
		repeatable: {
			date: undefined,
			remove: () => {
				this.closeNotify('repeatable');
			},
		},
		repeatableOff: {
			date: undefined,
			remove: () => {
				this.closeNotify('repeatableOff');
			},
		},
		timer: {
			date: undefined,
			remove: () => {
				this.closeNotify('timer');
			},
		},
		dateOnly: {
			date: undefined,
			remove: () => {
				this.closeNotify('dateOnly');
			},
		},
	};

	checking = new BehaviorSubject<boolean>(true);

	dateOnly = false;
	timeModeIcon: 'calendar' | 'clock' = 'clock';

	constructor(
		private data: DataService,
		private route: ActivatedRoute,
		private router: Router,
		private auth: AuthService,
		private cdr: ChangeDetectorRef,
		private action: ActionService,
		private notify: NotifyService,
	) {}

	ngOnInit(): void {
		this.form = new FormGroup({
			title: new FormControl(null, [Validators.required, Validators.maxLength(100)]),
			description: new FormControl(null, [Validators.maxLength(10000)]),
			difference: new FormControl(this.difference, [
				Validators.required,
				Validators.pattern(`^-?[0-9]{1,${this.validatorDifferenceMaxLength}}$`),
			]),
			direction: new FormControl('backward', [Validators.required]),
			greenwich: new FormControl(false),
			repeatable: new FormControl(false),
			public: new FormControl(false),
			color: new FormControl('gray'),
			iterationsForm: new FormGroup({
				rangePeriod: new FormControl(1, [Validators.required, Validators.min(1)]),
				repeatsMode: new FormControl('setRepeatsAmount', [Validators.required]),
				rangeAmount: new FormControl(2, [Validators.required, Validators.min(2)]),
				periodicity: new FormControl('perMinutes', [Validators.required]),
				monthOptions: new FormControl('dayOfMonth', [Validators.required]),
			}),
			pointModesForm: new FormGroup({
				firstModeTitle: new FormControl(null, [Validators.maxLength(100)]),
				secondModeTitle: new FormControl(null, [Validators.maxLength(100)]),
				firstModeEmoji: new FormControl('üë∑'),
				secondModeEmoji: new FormControl('üèù'),
			}),
		});

		this.subscriptions.add(
			this.route.pathFromRoot?.[1].url.subscribe({
				next: (data: any) => {
					this.type =
						data[0].path === 'create'
							? EditPointType.Create
							: data[0].path === 'edit'
								? EditPointType.Edit
								: EditPointType.CreateUrl;
				},
			}),
		);

		this.subscriptions.add(
			this.route.queryParams
				.pipe(
					tap(() => {
						if (this.isCreation || this.isIterationAdded) {
							this.checking.next(false);
						}
					}),
					filter(() => !this.isCreation && !this.isIterationAdded),
					distinctUntilChanged(),
					mergeMap(() => this.route.params),
					mergeMap((data: any) => (data['id'] ? this.data.fetchPoint(data['id']) : of(undefined))),
					tap((point: Point | undefined) => {
						if (!this.isCreation && !this.isIterationAdded) {
							this.point = point;
						}
						this.dateOnly = point?.dateOnly || false;
					}),
					mergeMap(() => this.auth.getUserData(this.point?.user)),
					tap(userData => {
						this.userData = userData;
					}),
					combineLatestWith(this.auth.eventEditAccessCheck$),
				)
				.subscribe({
					next: ([, { pointId, access }]) => {
						this.point && this.data.putPoint(this.point);
						if (this.point?.dateOnly && this.differenceModeArray.length > 4) {
							this.differenceModeArray = this.differenceModeArray.slice(2, this.differenceModeArray.length);
							if (this.differenceMode === 'hours' || this.differenceMode === 'minutes') {
								this.differenceMode = 'days';
							}
						}
						if (access && (pointId === this.point?.id || !pointId)) {
							this.checking.next(false);
							this.setValues();
							this.pointModes = this.point?.modes || [];
						}
						if (!this.isCreation && !this.isIterationAdded) {
							this.point && this.action.pointUpdated(this.point);
							this.sortDates();
						}
						this.cdr.markForCheck();

						if (this.iterationForm) {
							const iterationForm = this.iterationForm.nativeElement as HTMLElement;
							iterationForm.classList.add('form__section--active');
							this.iterationForm.nativeElement.scrollIntoView({
								behavior: 'smooth',
							});
							setTimeout(() => {
								iterationForm?.classList.remove('form__section--active');
							}, 500);
						}
					},
					error: err => {
						console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏/—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏:\n', err.message);
					},
				}),
		);

		this.subscriptions.add(
			this.form.valueChanges
				.pipe(
					startWith(this.form.value),
					distinctUntilChanged(),
					pairwise(),
					// –í—ã–∫–ª—é—á–µ–Ω–æ, —á—Ç–æ–±—ã —Å–æ–±—ã—Ç–∏–µ –Ω–µ —Å–æ—Ö—Ä–∞–Ω—è–ª–æ—Å—å, –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –∏—Ç–µ—Ä–∞—Ü–∏–∏
					// tap(([curr, prev]) => {
					// 	this.loading = false;

					// 	if (this.point) {
					// 		if (prev.greenwich !== curr.greenwich) {
					// 			this.point.greenwich =
					// 				this.form.controls['greenwich'].value;
					// 		}
					// 		if (prev.repeatable !== curr.repeatable) {
					// 			// –ë—ã–ª–æ —Ç–∞–∫. –ù–æ —Å—Ç–∞–ª–æ —Ä–∞–±–æ—Ç–∞—Ç—å –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ.
					// 			// –ï—Å–ª–∏ —Å–Ω–æ–≤–∞ —Å–ª–æ–º–∞–µ—Ç—Å—è, —Ä–µ—à–∏—Ç—å, –∫–∞–∫–æ–π –≤–∞—Ä–∏–∞–Ω—Ç –æ—Å—Ç–∞–≤–∏—Ç—å –∏ –¥–æ–¥–µ–ª–∞—Ç—å
					// 			// this.point.repeatable = !this.point.repeatable;
					// 			this.point.repeatable =
					// 				this.form.controls['repeatable'].value;
					// 			this.switchIteration();
					// 		}
					// 		if (prev.public !== curr.public) {
					// 			this.point.public =
					// 				this.form.controls['public'].value;
					// 		}
					// 		if (prev.color !== curr.color) {
					// 			this.point.color =
					// 				this.form.controls['color'].value;
					// 		}
					// 	}
					// }),
					debounce(() => timer(this._debounceTime)),
				)
				.subscribe({
					next: ([curr, prev]) => {
						if (+prev.difference !== +curr.difference || prev.direction !== curr.direction) {
							this.differenceChanged();
						}

						/**
						 * –ï—Å–ª–∏ –∏–∑–º–µ–Ω–µ–Ω —Ñ–ª–∞–≥ –ì—Ä–∏–Ω–≤–∏—á–∞, –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–∞–µ–º, —á—Ç–æ –Ω–∞–¥–æ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å
						 * –∏–∑–º–µ–Ω–µ–Ω–∏—è –ø–µ—Ä–µ–¥ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ–º –∏—Ç–µ—Ä–∞—Ü–∏–π
						 */
						if (this.notifies['greenwich'].date) {
							if (!!this.greenwichValue === !!this.point?.greenwich || !this.hasManyIterations) {
								this.notifies['greenwich'].remove();
							}
						} else if (!!this.greenwichValue !== !!this.point?.greenwich && this.hasManyIterations) {
							this.notifies['greenwich'].date = this.notify.add({
								title: '–°–æ—Ö—Ä–∞–Ω–∏—Ç–µ —Å–æ–±—ã—Ç–∏–µ –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∏—Ç–µ—Ä–∞—Ü–∏–π',
							});
						}

						/**
						 * –ï—Å–ª–∏ –µ—Å—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –≤–∫–ª—é—á–µ–Ω–Ω—ã—Ö –ø–æ–≤—Ç–æ—Ä–∞—Ö,
						 * —Ç–æ —É–¥–∞–ª—è–µ–º –µ–≥–æ –∫–æ–≥–¥–∞ –æ–Ω–æ –Ω–µ–∞–∫—Ç—É–∞–ª—å–Ω–æ.
						 * –ï—Å–ª–∏ –µ–≥–æ –Ω–µ—Ç, —Ç–æ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º, –∫–æ–≥–¥–∞ –∞–∫—Ç—É–∞–ª—å–Ω–æ
						 */
						if (this.notifies['repeatable'].date) {
							if (!this.repeatableValue) {
								this.notifies['repeatable'].remove();
							}
						} else if (this.repeatableValue && !this.repeatableValueSaved) {
							this.notifies['repeatable'].date = this.notify.add({
								title: '–ò–∑–º–µ–Ω–µ–Ω–∏–µ –∏—Ç–µ—Ä–∞—Ü–∏–π –±—É–¥–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–æ –ø–æ—Å–ª–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–æ–±—ã—Ç–∏—è',
							});
						}

						/**
						 * –ï—Å–ª–∏ –µ—Å—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –≤—ã–∫–ª—é—á–µ–Ω–Ω—ã—Ö –ø–æ–≤—Ç–æ—Ä–∞—Ö,
						 * —Ç–æ —É–¥–∞–ª—è–µ–º –µ–≥–æ –∫–æ–≥–¥–∞ –æ–Ω–æ –Ω–µ–∞–∫—Ç—É–∞–ª—å–Ω–æ.
						 * –ï—Å–ª–∏ –µ–≥–æ –Ω–µ—Ç, —Ç–æ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º, –∫–æ–≥–¥–∞ –∞–∫—Ç—É–∞–ª—å–Ω–æ
						 */
						if (this.notifies['repeatableOff'].date) {
							if (this.repeatableValue) {
								this.notifies['repeatableOff'].remove();
							}
						} else if (!this.isCreation && !this.repeatableValue && this.hasManyIterations) {
							this.notifies['repeatableOff'].date = this.notify.add({
								title: '–û—Ç–∫–ª—é—á–µ–Ω—ã –ø–æ–≤—Ç–æ—Ä—ã —Å–æ–±—ã—Ç–∏—è',
								text: '–í—Å–µ –∏—Ç–µ—Ä–∞—Ü–∏–∏ –∫—Ä–æ–º–µ –ø–æ—Å–ª–µ–¥–Ω–µ–π –±—É–¥—É—Ç —É–¥–∞–ª–µ–Ω—ã',
							});
						}

						this.cdr.markForCheck();
					},
					error: err => {
						console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ –≤ –ø–æ–ª–µ —Ñ–æ—Ä–º—ã:\n', err.message);
					},
				}),
		);

		this.subscriptions.add(
			interval(millisecondsInMinute).subscribe({
				next: () => {
					this.dateChanged(this.pointDate);
				},
				error: err => {
					console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞–±–æ—Ç–µ —Ç–∞–π–º–µ—Ä–∞:\n', err.message);
				},
			}),
		);

		this.subscriptions.add(
			this.data.eventAddPoint$.subscribe({
				next: point => {
					this.point = point;
					this.action.pointUpdated(this.point);
					this.success(undefined, 'pointAdded');
				},
			}),
		);

		this.subscriptions.add(
			this.data.eventEditPoint$.subscribe({
				next: ([point, editPointEvent]) => {
					this.point = point;
					this.sortDates();
					this.action.pointUpdated(this.point);
					this.success(point, editPointEvent);
					this.cdr.markForCheck();
				},
			}),
		);

		this.subscriptions.add(
			this.action.eventUpdatedPoint$.subscribe({
				next: point => {
					if (point) {
						this.point = point;
						this.pointDate = point.dates[0].date ? parseDate(point.dates[0].date) : new Date();
						this.form.controls['title'].setValue(point.title);
						this.form.controls['description'].setValue(point.description);
						this.form.controls['color'].setValue(point.color);
						this.dateChanged();
					}
				},
			}),
		);
	}

	ngAfterViewInit(): void {}

	ngOnDestroy(): void {
		this.subscriptions.unsubscribe();
		this.notifies['greenwich'].remove();
		this.notifies['repeatable'].remove();
		this.notifies['timer'].remove();
		this.notifies['dateOnly'].remove();
	}

	get formGroup(): any {
		return this.form;
	}

	get isCreation() {
		return this.type === EditPointType.Create || this.type === EditPointType.CreateUrl;
	}

	get isCreationBase() {
		return this.type === EditPointType.Create;
	}

	get isCreationUrl() {
		return this.type === EditPointType.CreateUrl;
	}

	get isTimer() {
		return this.dateUrlMode === 'timer';
	}

	get hasManyIterations() {
		return this.dates?.length && this.dates?.length > 1;
	}

	get isForward() {
		return this.form.controls['direction'].value === 'forward';
	}

	get dates() {
		return this.point?.dates;
	}

	get pointColorNames(): { [key: string]: string } {
		return PointColors;
	}

	get pointColorNamesInverted(): { [key: string]: string } {
		return getInvertedObject(PointColors);
	}

	get pointColors() {
		return Object.keys(PointColors) as PointColorTypes[];
	}

	get pointColor() {
		return this.form.controls['color'].value;
	}

	get pointColorName() {
		return this.pointColorNames[this.pointColor];
	}

	get isBaseFormValid() {
		return this.form.controls['title'].valid;
	}

	get isDateFormValid() {
		return this.form.controls['difference'].valid;
	}

	get differenceValue() {
		return +this.form.controls['difference'].value;
	}

	get pageTitle() {
		return !this.isCreation ? '–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ' : this.isCreationBase ? '–°–æ–∑–¥–∞–Ω–∏–µ' : '–°–æ–∑–¥–∞–Ω–∏–µ —Å–æ–±—ã—Ç–∏—è-—Å—Å—ã–ª–∫–∏';
	}

	get visibleDifference() {
		//  –ü–æ—Å—Ç–∞–≤–ª—é –æ–∫—Ä—É–≥–ª–µ–Ω–∏–µ ceil, –¥–∞—Ç–∞ —Å—Ç–∞–≤–∏—Ç—Å—è —Ç–æ—á–Ω–µ–µ. –ü–æ–Ω–∞–±–ª—é–¥–∞–µ–º.
		switch (this.differenceMode) {
			case 'hours':
				return Math.ceil(this.difference / minutesInHour);
			case 'days':
				return Math.ceil(this.difference / minutesInDay);
			case 'weeks':
				return Math.ceil(this.difference / (minutesInDay * 7));
			case 'months':
				const resInterval = intervalToDuration({
					start: subMinutes(new Date(), this.difference),
					end: new Date(),
				});
				return (resInterval.years ? resInterval.years * 12 : 0) + (resInterval.months ?? 0) || 0;
			case 'years':
				return (
					intervalToDuration({
						start: subMinutes(new Date(), this.difference),
						end: new Date(),
					}).years ?? 0
				);
			default:
				return this.difference;
		}
	}

	get greenwichValue() {
		return this.form.controls['greenwich'].value;
	}

	get publicValue() {
		return this.form.controls['public'].value;
	}

	/**
	 * –ï—Å–ª–∏ —É —Å–æ–±—ã—Ç–∏—è –∏–∑–º–µ–Ω–µ–Ω–∞ –º–Ω–æ–≥–æ–∫—Ä–∞—Ç–Ω–æ—Å—Ç—å, –Ω–æ –µ—â–µ –Ω–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞.
	 * –í–ª–∏—è–µ—Ç –Ω–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –∏ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å —Å–æ–∑–¥–∞–Ω–∏—è –Ω–æ–≤—ã—Ö –∏—Ç–µ—Ä–∞—Ü–∏–π
	 */
	get repeatableValue() {
		return this.form.controls['repeatable'].value;
	}

	/**
	 * –ï—Å–ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ –º–Ω–æ–≥–æ–∫—Ä–∞—Ç–Ω–æ—Å—Ç–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ
	 */
	get repeatableValueSaved() {
		return this.point?.repeatable;
	}

	trackBy(index: number, item: PointColorTypes): string {
		return item;
	}

	closeNotify(name: string) {
		const date = this.notifies[name].date;
		if (date !== undefined) {
			this.notify.close(date);
			this.notifies[name].date = undefined;
		}
	}

	sortDates() {
		const sortedDates = this.point && setIterationsMode(sortDates(this.point)).dates;

		if (this.point && sortedDates) {
			this.point.dates = sortedDates;
		}
	}

	setValues(
		{
			isReset,
			isFirstLoading,
		}: {
			isReset?: boolean;
			isFirstLoading?: boolean;
		} = {
			isReset: false,
			isFirstLoading: false,
		},
	) {
		(!this.isIterationSwitched || isFirstLoading) &&
			this.form.patchValue(
				{
					title: this.point?.title,
					description: this.point?.description,
					direction: this.point?.direction ?? 'backward',
					greenwich: this.point?.greenwich || false,
					repeatable: this.point?.repeatable || this.isIterationAdded || false,
					public: this.point?.public || false,
					color: this.point?.color ?? 'gray',
				},
				{
					emitEvent: false,
				},
			);
		if (this.point?.modes) {
			this.form.get('pointModesForm')?.patchValue({
				firstModeTitle: this.point.modes[0].name,
				secondModeTitle: this.point.modes[1].name,
				firstModeEmoji: this.point.modes[0].icon,
				secondModeEmoji: this.point.modes[1].icon,
			});
		}

		const currentPointDate = getPointDate({
			pointDate: isReset ? new Date() : parseDate(this.dates?.[this.currentIterationIndex || 0]?.date),
			isGreenwich: this.isIterationAdded ? false : this.greenwichValue,
		});

		this.pointDate = isDateValid(currentPointDate) ? currentPointDate : new Date();

		this.selectedIterationDate = this.pointDate;

		this.dateChanged(this.pointDate);
	}

	dateChanged(date?: Date) {
		this.difference = this.convertToMinutes(+(date || this.pointDate) - +new Date());

		this.setVisibleDifference();
	}

	differenceChanged(diff: number = +this.differenceValue) {
		const currentDate = new Date();
		let diffMs!: number;
		let targetDate!: Date;

		switch (this.differenceMode) {
			case 'hours':
				diffMs = diff * millisecondsInHour;
				break;
			case 'days':
				diffMs = diff * millisecondsInDay;
				break;
			case 'weeks':
				diffMs = diff * millisecondsInDay * 7;
				break;
			case 'months':
				targetDate = addMonths(currentDate, diff);
				break;
			case 'years':
				targetDate = addYears(currentDate, diff);
				break;
			default:
				diffMs = diff * millisecondsInMinute;
				break;
		}

		if (targetDate && !isDateValid(targetDate)) {
			targetDate = this.pointDate;
			if (diff < 0) {
				targetDate = setYear(targetDate, 1);
			} else if (diff > 9999) {
				targetDate = setYear(targetDate, 9999);
			}
			this.dateChanged(targetDate);
		}

		if (getYear(targetDate) < 1) {
			targetDate = setYear(targetDate, 1);
			this.dateChanged(targetDate);
		} else if (getYear(targetDate) > 9999) {
			targetDate = setYear(targetDate, 9999);
			this.dateChanged(targetDate);
		}

		!targetDate && (targetDate = new Date(currentDate.getTime() + diffMs));
		// –ü—Ä–∏—à–ª–æ—Å—å —É–ø—Ä–æ—Å—Ç–∏—Ç—å, –∫–æ–≥–¥–∞ –¥–æ–±–∞–≤–∏–ª –≤—ã–≤–æ–¥ –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π
		// const targetDate = this.isForward
		// 	? new Date(currentDate.getTime() - diff * millisecondsInMinute)
		// 	: new Date(currentDate.getTime() + diff * millisecondsInMinute);

		isDateValid(targetDate) && (this.pointDate = targetDate);
	}

	switchIteration(i: number = this.currentIterationIndex, isSwitched = false) {
		const isFirstLoading = !this.currentIterationIndex;
		this.isIterationSwitched = isSwitched;
		this.currentIterationIndex = i;
		this.isIterationAdded = false;
		if (this.isIterationSwitched) {
			this.setValues({
				isFirstLoading,
			});
		}
	}

	switchColor(color: string) {
		this.form.controls['color'].setValue(color);
		this.colorDrop.closeHandler();
	}

	addIterationHandler() {
		this.iterationForm.nativeElement.scrollIntoView({
			behavior: 'smooth',
		});
		this.isIterationAdded = true;
		this.setValues({
			isReset: true,
		});
	}

	differenceModeChanged(value: string | number) {
		this.differenceMode = value as DifferenceMode;
		localStorage.setItem('differenceMode', this.differenceMode);
		this.dateChanged();
	}

	convertToMinutes(ms: number): number {
		return Math.ceil(ms / millisecondsInMinute);
		// –û—Å—Ç–∞–≤–∏–ª —Ç–æ–ª—å–∫–æ ceil, –∫–æ–≥–¥–∞ –Ω–∞—á–∞–ª –≤—ã–≤–æ–¥–∏—Ç—å –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
		// return Math[this.isForward ? 'trunc' : 'ceil'](
		// 	Math.abs(ms) / millisecondsInMinute
		// );
	}

	getRepeats(repeats: Iteration[]) {
		this.submit(false, repeats);
	}

	setIterationsControls(controls: any) {
		this.iterationControls = controls;
	}

	modeSelected(mode: CalendarMode) {
		this.calendarMode = mode;
	}

	datePicked(date: Date) {
		this.pointDate = date;
		this.dateChanged();
	}

	setVisibleDifference() {
		this.form.controls['difference'].setValue(this.visibleDifference, {
			emitEvent: false,
		});
	}

	switchDateUrlMode(mode: string) {
		this.dateUrlMode = mode as 'date' | 'timer';

		if (this.notifies['timer'].date) {
			if (this.dateUrlMode === 'date') {
				this.notifies['timer'].remove();
			}
		} else {
			this.notifies['timer'].date = this.notify.add({
				title: '–ü—Ä–∏ –≤—ã–±–æ—Ä–µ —Ä–µ–∂–∏–º–∞ &laquo;—Ç–∞–π–º–µ—Ä&raquo; –æ—Ç—Å—á—ë—Ç –≤—Å–µ–≥–¥–∞ –±—É–¥–µ—Ç –æ—Ç&nbsp;–∑–Ω–∞—á–µ–Ω–∏—è, —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ –≤&nbsp;—Å—Å—ã–ª–∫–µ',
				text: '–ü–æ—Å–ª–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—Ç—Ä–∞–Ω–∏—Ü—ã –æ—Ç—Å—á—ë—Ç –Ω–∞—á–Ω—ë—Ç—Å—è –∑–∞–Ω–æ–≤–æ',
			});
		}
	}

	pointModeChanged(modes: PointMode[]) {
		this.pointModes = modes;
		this.modesDrop.closeHandler();
	}

	pointModeClosed() {
		this.pointModes = [];
		this.modesDrop.closeHandler();
	}

	pointModesOpened() {
		from(fetchEmojis('ru'))
			.pipe(combineLatestWith(fetchMessages('ru')), take(1))
			.subscribe({
				next: ([emojis, messages]) => {
					this.emojis = [];
					messages.groups.forEach((item, i) => {
						item.message !== '–∫–æ–º–ø–æ–Ω–µ–Ω—Ç' &&
							this.emojis.push({
								title: item.message.slice(0, 1).toUpperCase() + item.message.slice(1),
								list: emojis.filter(emoji => emoji.group === i),
							});
					});

					this.emojis.push({
						title: '–ü—Ä–æ—á–∏–µ',
						list: emojis.filter(emoji => emoji.group === undefined),
					});
				},
			});

		this.isModesDropOpened = true;
	}

	pointModesClosed() {
		this.isModesDropOpened = false;
	}

	dateOnlySwitch(event: Event) {
		this.dateOnly = !(event.target as HTMLInputElement).checked;
		this.timeModeIcon = this.dateOnly ? 'calendar' : 'clock';
		this.form.controls['greenwich'].setValue(this.dateOnly ? false : this.point?.greenwich);
		/**
		 * –ï—Å–ª–∏ –≤—Ä–µ–º—è –≤ –∫–∞–ª–µ–Ω–¥–∞—Ä–µ –æ—Ç–∫–ª—é—á–µ–Ω–æ, –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–∞–µ–º,
		 * —á—Ç–æ –Ω–∞–¥–æ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è –ø–µ—Ä–µ–¥ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ–º –∏—Ç–µ—Ä–∞—Ü–∏–π
		 * –∏, –¥–∞—Ç–∞ —Å—Ç–∞–≤–∏—Ç—Å—è –ø–æ –º–µ—Å—Ç–Ω–æ–º—É –≤—Ä–µ–º–µ–Ω–∏
		 */
		if (this.notifies['dateOnly'].date) {
			this.notifies['dateOnly'].remove();
		} else if (this.dateOnly && !this.point?.dateOnly) {
			this.notifies['dateOnly'].date = this.notify.add({
				title: '–í—Ä–µ–º—è –≤ –∫–∞–ª–µ–Ω–¥–∞—Ä–µ –æ—Ç–∫–ª—é—á–µ–Ω–æ',
				text: '–°–æ–±—ã—Ç–∏–µ –±—É–¥–µ—Ç –æ—Ç–æ–±—Ä–∞–∂–∞—Ç—å—Å—è –ø–æ –º–µ—Å—Ç–Ω–æ–º—É –≤—Ä–µ–º–µ–Ω–∏',
			});
		}
	}

	submit(saveIteration = false, repeats: Iteration[] = []) {
		if (this.form.invalid) {
			return;
		}

		// –ù—É–∂–Ω–æ –ª–∏ —ç—Ç–æ? –ü—Ä–∏ differenceChanged –±–µ—Ä–µ—Ç—Å—è –Ω–µ –¥–∞—Ç–∞, –∞ —Ä–∞–∑–Ω–∏—Ü–∞
		// this.differenceChanged();
		this.loading = true;
		let newDatesArray = [] as Iteration[];

		this.dates?.forEach(item => {
			const currentItem = {
				date: item.date,
				reason: item.reason,
			} as Iteration;
			item.comment && (currentItem.comment = item.comment);
			newDatesArray.push(currentItem);
		});
		let editPointEvent: EditPointEvent = 'pointEdited';

		const dateTime = format(
			getPointDate({
				pointDate: this.pointDate,
				isGreenwich: this.greenwichValue,
				isInvert: true,
			}),
			Constants.fullDateFormat,
		);

		const lastDate = {
			date: dateTime,
			reason: 'byHand',
		} as Iteration;

		if (repeats.length) {
			newDatesArray?.push(...repeats);
			editPointEvent = 'iterationsGenerated';
		} else if (saveIteration) {
			if (!this.repeatableValue || this.isCreation) {
				newDatesArray = [lastDate];
			} else if (this.isIterationAdded) {
				newDatesArray?.push(lastDate);
				editPointEvent = 'iterationAdded';
			} else if (newDatesArray) {
				newDatesArray[this.currentIterationIndex] = lastDate;
				editPointEvent = 'iterationEdited';
			}
		} else if (!this.repeatableValue || this.isCreation) {
			newDatesArray = [lastDate];
		}

		if (this.dateOnly) {
			newDatesArray.forEach(item => {
				item.date = format(startOfDay(parseDate(item.date)), Constants.fullDateFormat);
			});
		}

		let result = {
			dates: newDatesArray,
		} as Point;

		if (!saveIteration && !repeats.length) {
			result = Object.assign(result, {
				title: this.form.controls['title'].value,
				description: this.form.controls['description'].value ?? null,
				direction: this.form.controls['direction'].value,
				greenwich: this.greenwichValue,
				repeatable: this.repeatableValue,
				public: this.publicValue,
				user: this.auth.uid ?? '',
				color: this.form.controls['color'].value ?? 'gray',
				modes: this.pointModes.length && this.repeatableValue ? this.pointModes : null,
				dateOnly: this.dateOnly,
			});
		} else {
			result = Object.assign(result, {
				title: this.point?.title,
				description: this.point?.description ?? '',
				direction: this.point?.direction,
				greenwich: this.point?.greenwich,
				repeatable: this.point?.repeatable,
				public: this.point?.public,
				user: this.point?.user,
				color: this.point?.color ?? 'gray',
				modes: this.point?.modes?.length && this.point?.repeatable ? this.point.modes : null,
				dateOnly: this.point?.dateOnly,
			});
			this.isIterationSwitched = true;
		}

		if (this.isCreationBase) {
			this.data.addPoint(result);
		} else if (this.isCreationUrl) {
			const urlParams: any = {
				color: result.color !== 'gray' && result.title ? result.color : null,
				title: result.title,
				description: result.description,
				date: this.dateUrlMode === 'date' ? format(parseDate(result.dates[0].date), Constants.fullDateUrlFormat) : null,
			};

			if (this.dateUrlMode === 'timer') {
				this.differenceValue ? (urlParams[this.differenceMode] = this.differenceValue) : (urlParams['minutes'] = 0);
			}

			this.router.navigate(['/url/'], {
				queryParams: urlParams,
			});
		} else if (saveIteration || repeats.length) {
			if (newDatesArray) {
				this.data.editPoint(
					this.point?.id,
					{
						...result,
						repeatable: true,
						dates: newDatesArray,
						id: this.point?.id,
					} as Point,
					editPointEvent,
					lastDate,
				);
			}
		} else {
			this.data.editPoint(this.point?.id, {
				...result,
				id: this.point?.id,
			} as Point);
		}
	}

	success(point: Point | undefined, editPointEvent: EditPointEvent) {
		this.loading = false;
		point &&
			(this.point = {
				...this.point,
				...point,
			});
		this.point?.id &&
			this.router
				.navigate(['/edit/' + this.point?.id.toString()], {
					queryParams: {
						iteration: isNaN(this.currentIterationIndex) ? null : this.currentIterationIndex + 1,
					},
				})
				.then(() => {
					editPointEvent &&
						this.notify.add({
							title: EditPointSuccessMessage[editPointEvent],
							short: true,
							view: 'positive',
						});
				});
	}
}
